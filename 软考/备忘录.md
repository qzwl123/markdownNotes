路径覆盖

条件覆盖



应用层

- **各种应用程序和网络之间的接口**
- 电子邮件、远程登录、文件传输
- 常见协议：POP3(收协议的)、SMTP（发协议的）、FTP、HTTP、Telent(远程登陆)、DNS

表示层

- **数据的表示，安全，压缩**。将接收到的**数据翻译成二进制数，组成的计算机语言**，并对数据进行**压缩**和解压，**数据加密**和**解密**等工作，**数据的转换**
- 常见的协议LPP、NBSSP
- **URL加密**、口令加密、**图片编解码**

会话层：

- **建立、管理、中止会话**管理是否允许不同机器上的用户之间建立会话连接关系
- **SSL**,LDAP
- 场景：服务器验证用户登录、断点续传、**Session,Cookie**

传输层 ： 四风交换机、四层的路由器

- 提供建立，**维护和拆除传输连接**的功能，起到承上启下作用
- 功能：**数据分段**、**端到端连接**、**拥塞控制**、错误检查和**重传**
- SNMP(简单网络管理协议),TCP,UDP

网络层 : 三层交换机、路由器

数据链路： 网桥、以太网交换机、网卡

物理层: 中继器、集线器、双绞线

摘要 ： 篡改



界面设计所提出的三条黄金准则 ： 用户操纵控制、保持界面一致、减轻用户的记忆负担

DFD数据流 ： 画数据流不是控制流



 **拥有者**有读、写、执行权限；而属**组用户**和**其他用户**只有读、执行权限。-rwx--x--x (711)



```c++
class Animal {
public:
    virtual void speak() {
        std::cout << "Animal sound" << std::endl;
    }
};

class Dog : public Animal {
public:
    void speak() override { // 覆盖基类实现
        std::cout << "Woof!" << std::endl;
    }
};
```



```c++
class Shape {
public:
    virtual double area() const = 0; // 纯虚函数
    virtual ~Shape() = default;
};

class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    double area() const override {
        return 3.14159 * radius * radius;
    }
};
```



数据字典 ：DD

数据建模 ：E-R

功能建模 ：DFD 自顶向下、从抽象到具体

状态迁移 ：STD

行为建模 ：UML (状态转换图)

逻辑模型 ：在采用结构化方法进行系统分析时，根据分解与抽象的原则  DFD

> 码距为 $\geq$ **3** 具有纠错和检错能力

## 海明码校验码

$ x^k-1 \geq n+k $ **n:数据位**，**k:校验量**

## 循环冗余校验码

主要用于**检错**，其本身**不具备纠错功能**

## 流水线

表示：**I**输入**0.1s**、**C**计算**0.2s**、**O**输出**0.3s**、**n**任务数量**5**

顺序执行公式：$总时间 = 第一条指令的任务时间(总时间) * n $ 例：$ (0.1 + 0.2 + 0.3) * 5 = 60s$

流水线公式 ：$ 总时间 = 第一条指令的任务时间(总时间) + (n - 1)* 最长任务时间 $ 例：$ (0.1 + 0.2 + 0.3)+ (5 - 1) * 0.3 = 30.3s$

加速比公式 ：$ 顺序执行 \div 流水线 $  例：$60s \div 30.3s = 1.98 = 198\%$

操作周期公式：最长操作时间段 例：0.3s

吞吐量公式 ：$ 最长操作时间段的倒数 \frac{10}{3}(\frac{3}{10}的倒数\frac{10}{3}) $

执行n条指令的吞吐率 ： $ n \div 流水线总时间$

## 存储器

1. 静态存储器(Cache 高速缓存) SRAM
2. 动态随机存储器（**主存**储器） DRAM 周期性的刷新
3. 可擦除可编程的**只读**存储器 EPROM
4. 电可擦除可编程的只读存储器 EEPROME
5. 闪速存储器（Flash） 整块（以块为单位）删除可以在数秒内删除 （类似 U 盘）

按访问方式分类（↓）

随机存储器 RAM、顺序存储器 SAM、直接存储器 DAM

相联存储器是一种按**内容**访问的存储器

虚拟存储器由**主存**和**辅存**构成 

<a id="例1"> </a>例1：cpu -> 内存 -> 地址（0x1、0x2、0x3）

([例1](#例1)) 空间局部性：当前访问为0x2存储单元，但在不久的将来可能访问相邻的 0x1 or 0x3

([例1](#例1)) 时间局部性：当前访问为0x2存储单元,但在不久的将来可能还会访问 0x2

## 输入输出（I/O）控制方式

1. 程序查询方式
   - `CPU和IO（外设）只能串行工作`CPU需要一直轮询检查长期处于忙等状态。CPU利用率低
   - **一次只能读/写一个字**
   - **由CPU将数放入内存**
2. 中断驱动方式（需要保护现场、需要CPU干预）
   - IO设备通过中断信号主动向CPU报告IO操作已经完成
   - `CPU和IO(外设)可并行工作`
   - CPU利用率得到提升
   - **一次只能读/写一个字**
   - **由CPU将数放入内存**
3. 直接存储器方式（DMA）（不需要保护现场、需要CPU干预）
   - `CPU和IO(外设)可并行工作`
   - `仅在传送数据块的"开始"和"结束"时才需要*CPU的干预(中断)*`
   - `由外设直接将数据存入内存(主存)`
   - `一次读写的单位以"块"而不是字`
   - 列题：↓
     - "DMA传送结束"为中断、"处运算时除数为0"为异常
     - CPU是在`一个总线周期`结束时响应DMA的请求
     - 采用DMA方式传送数据时，每传送一个数据都需要占用一个`存储周期`

## 总线(13种)

> 数据总线、地址总线、控制总线 3类（数、地、控）

1. PCI总线
   - 采用的内总线，采用并行传输方式`（并行内总线）`
2. SCSI总线
   - `是一条并行外总线`
3. ISA总线
   - 工业标准总线，只支持16为的IO设备，数据传输率大约16Mb/s
4. EISA总线 
   - 32总线(地址线、数据先、其他控制信号线、电源、地线)，数据传输率大约33Mb/s

例题：↓

- 在计算机系统中采用总线结构，便于实现系统的积木话构造，同时可以`减少信息传输的数量`

- 总线复用方式可以`减少总线中信号的数量`

- 总线宽度为32bit，时钟频率为200MHz，若总线每5个时钟周期期间传送一个32bit的字,则该总线`32 / 5 * 200MHz = 1280Mbit / 8 = 160MBit`

## 加密技术与认证技术

> 公：加密 验证(认证)
>
> 私：解密 签名(加密)

1. 加密技术 (主要解决 `窃听` )

- 对称密钥（私有、私有密钥加密、共享密钥加密算法）算法：
  1. DES
  2. 3DES
  3. RC-5
  4. IDEA
  5. AES (分组)
  6. RC4
- 对称加密(私有密钥加密)（加密解密都是同一把密钥）
  - 缺：密钥分发有缺陷
  - 优：加密解密速度快、适合加量大量明文数据
- 非对称密钥（公钥、公开密钥加密）算法：
  1. RSA
  2. ECC
  3. DSA
- 非对称加密(公开密钥加密)（加密和解密不是同一把密钥，分别是公钥和私钥）
  - 用公钥加密只能用私钥解密
  - 用私钥加密只能用公钥解密
  - 不能通过一把推出另一把
  - 用接收方的公钥加密
- 混合加密
  - 先用对称密钥加密，之后在通过非对称加密，加密对称加密的结果 和 对称加密的密钥

2. 认证技术 （处理一个主动攻击）

- 摘要（主要解决 `篡改` ）Hash函数、MD5摘要算法
  - 将要发送的明文进行Hash算法后得到摘要A，将摘要A与密文一起发送过去，接收方先进行解密，在对解密后的数据进行相同的Hash算法得出摘要B,最后进行摘要A与摘要B进行比对，从而验证数据是否被篡改
  - Ps:一般摘要会和数据签名一起使用
- 数字签名（主要解决 `否认` ）
  - 发送方用自己的私钥对摘要A进行签名(加密)，得到数字签名和密文一起发送
  - 接收方,用发送方的公钥对数字签名进行认证(解密)（确认信息的来源后就不可否认了），在将密文解密之后的明文进行Hash算法得到摘要B，最后进行摘要A与摘要B进行比对，从而验证数据是否被篡改
- 数字证书（主要解决 `假冒` ）
  - 用户向AC机构申请数字证书，将个人信息和公钥发给CA机构，CA机构颁给用户数字证书，数字证书用CA私钥进行签名(加密)，用户可以向CA机构申请数字证书并用CA公钥进行验证(解密)，得到用户公钥

SHA-1安全散列算法

## 可靠性公式

- 串联系统
  - R = R~1~ * R~2~ * R~3~ * R~....~ * R~N~
- 并联系统
  - R = 1 - (1 - R~1~) * (1 - R~2~) ... (1 - R~n~)

![image-20250322112556627](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250322194037498.png)

## 规格化浮点数

浮点数表示的数值范围只要由**阶码决定**，所表示数值的**精度**则由**尾数决定**

规格化就是将尾数绝对值限定在区间**[0.5,1]**

E 称为阶码（如果是**浮点数**阶码 则 **包含1位**符号位）

F 尾数

$N = 2^E * F$



R位的移码表述，M尾数(包括1位数符)当尾数用补码表示时：

最大的正数：$ +(1-2^{-M+1} * 2^{(2^{R-1}-1)}) $

最小的负数：**$-1 * 2^{(2^{R-1}-1)}) $**

![image-20250416210654061](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250416210701388.png)

# 第二章

## 编译器与解释器

- 解释器：
  - **翻译源程序**时**不生成**独立的**目标程序**（不生成目标程序）
  - **解释程序**和**源程序**要**参与到程序的运行**过程中（参与运行控制，程序执行的速度慢）
  - 解释方式(阶段)：词法分析、语法分析、语义分析（**不可省略，顺序不可变换**）
- 编译器：
  - 翻译时将源程序翻译成独立保存的目标程序（生成目标程序）
  - 机器上运行的是与源程序等价的目标程序，源程序和编译程序都**不在参与目**标程序的**运行**过程（不参与到程序运行）
  - 编译方式(阶段)：词法分析、语法分析、语义分析、**中间代码生成**、**代码优化**、目标代码生成（**4，5可以省略，词语语不可省略顺序不可更改**）
- 符号表
  - **不断收集、记录和使用源程序中**一些相关符号的类型和特征等信息，并将其存入符号表中
  - 记录源程序中各个字符的必要信息，以辅助语义的正确性检查和代码生产

![image-20250323174352685](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250323174359878.png)

## 词法分析

`识别记号`

（输入）源程序 -> 词法分析 -> 记号流 (输出)

源程序看成一个多行的字符串，从前到后(从左到右)，逐个字符扫描从中识别出一个个"**单词**"符号是程序设计语言的基本语法单位，如 关键字(或保留字)、标识符、常数、运算符、分隔符(如标点符号、左右括号)等

例：↓

![image-20250323175724755](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250323175724865.png)

## 语法分析

`识别句子结构`、`检查语法错误`

（输入）记号流 -> 语法分析 -> 语法树(分析数) (输出)

语法分析阶段的主要作用是：

语法分析阶段可以发现程序中的所有语法错误

对各条语句的结构进行合法性分析，分析程序中的句子结构是否正确

例 ：↓

- int a = 3`;` 假如当我们没有写分号，那么这个就是语法问题
- 最经典的是就是括号不匹配`[]、{}、()`
- `b` = 1 + 2; b未定义



## 语义分析

`填写符号表`、`生成中间代码`

（输入）语法树 -> 语义分析 ->  (输出)

语义分析主要检查源程序是否包含**静态**语义错误

左右两边数据类型不匹配（**在运行之前检查出来的错误**）

语义分析阶段**不能发**现程序中**所有的语义错误**

**不能发现动态语义错误**，动态语义错误运行时才能发现

列 ： ↓

- 整除取余运算符只能对整型数据进行运算，若其运算对象中有浮点数就认为是类型不匹配的错误
- int a = "1adasf";



## 目标代码生产

目标代码生成阶段的工作与具体的机器密切相关

**寄存器的分配**工作处于目标代码生产阶段

## 中间代码生成

常见的中间代码有：**后缀式、三地址码、三元式、四元式和树(图)等形式**。

中间代码与具体的机器无关（**不依赖具体的机器**）

可以将不同的高级程序语言翻译成同一种中间代码

中间代码可以跨平台

因为与具体的机器无关，使用中间代码有利于进行与机器无关的优化处理和提高编译程序的可移植性

## 程序设计语言的规定

1. 便于为数据合理分配存储单元
2. 便于对参与表达式计算的数据对象进行检查
3. 便于规定数据对象的取值范围及能够进行的运算



and(&& 逻辑与)、or(|| 逻辑或)、not(! 非 右结合)

例 : not Z = !Z 、 not 2 + 3 = not (2 + 3) 先算 2 + 3 

## 正规式与正规集

|           正规式            |            正规集            |
| :-------------------------: | :--------------------------: |
| \| : 选择，a和b只能选择一个 |   * : 闭包，出现0次或多次    |
|             ab              |       字符串构成的集合       |
|            a\|b             |     字符串a、b构成的集合     |
|             a*              | 由0个或多个a构成的字符串集合 |
|           (a\|b)*           | 所有字符a和b构成的字符串集合 |
|          a(a\|b)*           | 以a为首字符a、b字符串的集合  |
|         (a\|b)*abb          | 以abb结尾的a、b字符串的集合  |

## 有限自动机

有限自动机是**词法分析**的一个工具，它能正确地识别正规集

确定有限自动机(DFA) : 对每一个状态来说识别字符后转移的状态是唯一的

不确定的有限自动机(NFA) : 对每一个状态来说识别字符后转移的状态是不确定的

初态 : 由一个箭头和一个圆圈构成→⚪）

终态 : 由两个圆圈构成

特殊情况 ：既可以是初态又可以是终态，还有可能由多个终态，**ε**代表空不需要任何条件就可以转换

## 上下文无法文法

E -> T | E+T

T -> F | T*F

F -> -F | N

N -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

大多数程序设计语言的语法规则用`上下文无关文法`描述即可

## 中缀后缀表达式

（a `?` b）中缀(算数表达式) : 1 `+` 2、1 `-` 2、 1 `*` 2、 1 `/` 2

（a ? `b`）后缀(逆波兰) : 1 2 `+`、 1 2 `-`、 1 2 `*`、1 2 `/`

优先级 ： 1.`()`2.`x、/`3.`+、-` (优先级相同，`从右向左` 中边后)

优先级 ： 1.`()`2.`>(大于号)`3.`&&、||` (优先级相同，`从右向左` 中边后)

## 杂题

1. **脚本语言**都是**动态语言**，其程序结构可以在运行中改变，而动态语言都是解释型语言 (√)
2. **编程过程中**为变量分配存储单元所用的地址是**逻辑地址**，**程序运行**时再映射为**物理地址**
3. 递归下降分析方法是一种`自上而下的词法分析`
4. 移进一归约分析法是编译程序(或解析程序)对高级语言源程序进行语法分析的一种方法，属于`自低向上(或自下而上)`的语法分析方法 2016上
5. Java、Python和JavaScript都是**解释型**本程序设计语言，其中python和JavaScript是**脚本语言**、C/C++是**编译型**程序设计语言
6. 用**脚本语言**编程时也会使用**变量**以及定义和调用函数
7. 函数式编程语言 Lisp、逻辑式编程语言 Prolog
8. 语法指导翻译是一种`静态语义分析`
9. C/C++ 预处理、编译、汇编、链接
10. Java 采用即时编译，对象在堆空间分配，自动垃圾回收处理
11. Python 支持(跨平台，面向对象程序设计，动态编程) 不支持(编译型)

# 第三章知识产权

## 著作权（也称版权）（保护期限 终身 + 死后50）

是指作者对其创作的作品享有的**人身权**和**财产权**

人身权包括：发表权(终身+死亡后50年)、署名权、修改权、保护作品完整权

## 计算机软件著作权

计算机软件著作权的主体是指享有著作权的人。根据**著作权法**和1991**<<计算机软件保护条例>>**(由国务院颁布)前身(1990<<中华人民共和国著作权法>>)

保护：计算机程序与相关文档

不保护：思想、概念、发现、原理、算法、处理过程、和运算方法

开源软件著作权归开发者所有，但使用者可以修改、分发

- 计算机软件著作权的**客体**
  -  著作权法保护的计算机软件是指**计算机程序**(包括：源程序和目标程序)及其**有关文档**(文档一般以程序设计说明书，流程图和用户手册)
- 计算机软件著作权的保护期
  - 根据<<著作权法>>和<<计算机软件保护条例>>的规定，计算机软件著作的权利自**软件开发完成之日起产生，保护期为50年。保护期满，除开发者身份权(署名权)以外，其他权利终止**
- 职务开发软件著作权的归属
  - 指公民在单位**任职期间**为执行**本单位工作任务所开发**的计算机软件,公民只享有**署名权**其他都归公司所有
  - 若开发的软件不是执行本职工作的结果，其著作权就不属单位享有，如果该雇员主要使用了单位的设备就不能属于雇员个人享有 
- 委托开发的软件著作权归属
  - **有合同**就按约定走，**没有合同**或合同未作明确约定，其软件著作权由受委托人享有
- 商业秘密（保护期限 保护期限不固定，只要不公开）
  - 指不为公众所知悉的、能为权利人带来的经济利益、具有实用性并经权利采取保密措施的**技术信息**和**经营信息**
- 专利申请（保护期限 发明 20，实用型、外观 10 年）
  - "即一份申请一项发明"，两个两个以上的人分别就同样的发明创造申请专利的**，专利授权给最先申请的人**，**同一天**申请的**两人进行协商**，两个人协商失败，进行二次申请
- 商标权
  - 我国商标权的保护期限自核准**注册之日**起**10年**，期限届满**前6个月**内申请**续展注册每次续展有效10年**次数不限
  - 软件商标权的权利人是指`软件注册商标所有人`
- 商标注册
  - 先注册先得，同一天注册先使用先得，如果都没有使用最后进行协商

# 第四章数据库

## 概念数据模型

三级模式二级映像

三级模式：

- 概念模式(模式) -> 基本表
-  
- 内模式(存储模式) -> 存储文件

二级映像：

- 模式 / 内模式映像(存储)。 存在与概念及和内部级之间，实现了概念模式和内模式的相互转换`为了保证物理独立性，需要修改概念模式和内模式直接的映像`
- 外模式(视图) / 模式映像。实现了外模式和概念模式的相互之间的转换`为了保证应用程序能够正确执行，需要修改外模式和概念模式之间的映像`

## 关系模型中的关系完整性约束

- 实体完整性 : 关系中主码的值不能为空或部分为空。也就是说，主码中属性即主属性不能取空值。（`主码不能为空，外键也不能为空`） 
- 参数完整性 : 如果关系R~2~的外码X与关系R~1~的主码相对应(基本关系R~1~和R~2~不一定是不同的关系，即它们可以是同一关系)，则外码X的每个值必须在关系R~1~中主码的值中找到，或为空（`在一个关系二维表中R2，存在主码与外码，外码的属性值要么存在于R1中，要么为NULL`）
- 用户自定义的的完整性 : 指用户对某一具体数据指定的约束条件进行校验

## 关系的数学定义

关系模式 = 属性行

![image-20250329113016975](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250329113024144.png)

1. 笛卡尔积（二元）

**SQL 投影 + 笛卡尔积：select ? from ?, ?**

```sql
select R.A R.B R.C, S.A S.B S.D from R, S
```



![image-20250329113046264](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250329113046388.png)

2. 并（二元）、交、差

![image-20250329113119519](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250329113119630.png)

3. 投影(π)（一元）

**SQL 投影：select ? from ?**

例 ： (π~A,B,C~(R)) :

```sql
select A,B,C from R
```

投影运算是从关系的**垂直方向**进行运算，在关系R中**选出若干属性列**A组成新的关系记作π~A~(R)

![image-20250329150415379](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250329150415521.png)

4. 选择(σ)（一元）

**SQL 投影 + 选择：select ? from ? where ?**

```sql
select A,B,C from R where B >= 5
```



选择运算是从关系的**水平方向进行运算**是从关系R中选择满足给定条件的**元组**(行),记作σ~F~(R)

F中的运算是一个表达式，对属性名(或列的序号)或常熟，运算符，算数比较符(<、<=、>、>=、≠)和逻辑运算符(与(∧)、或(∨)、非(¬))

![image-20250329153954288](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250329153954416.png)

5. 连接(∞)

```sql
select R.A, R.B, R.C, S.D from R, S where R.B = S.B and R.C = S.C 
```



连接运算是从**两个关系R和S的笛卡尔积中选取满足条件的元组**。

- θ连接（θ是一个比较运算符 ）

- 等值连接（θ 为 "="时称之为等值连接 如 ：R ∞ S R.B = S.B)
- 自然连接（自然连接就是除去重复属性的等值连接）

自然连接例子 ：↓（挑选相同公共属性下面属性分为R(`A`,B,C)，S(`A`,D,E)，选择(**所有相等的公共属性**)R.A = S.A 的元组，并去除S(后面相同公共属性的列`S.A列`)），如果所有元组 **R.A ≠ S.A**，那么就是**空集**

PS : 如果有两个公共属性相等，如A和B, 那么就需要判断 R.A = S.A **并且** A.B = S.B, 如果**不存在相等的公共属性**，那么就是**笛卡尔积**

![image-20250329193445724](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250329193445990.png)

6. 除

除运算是同时从关系的**水平方向**和**垂直方向**进行运算

![image-20250329220343284](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250329220343486.png)

## 外连接

外连接运算是**连接运算**的**扩展**，可以处理由于连接运算缺失的信息

![image-20250329214227094](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250329214227306.png)

- 左外连接（符号 在连接左侧有直线延申）

![image-20250329214410437](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250329214410669.png)

- 右外连接

![image-20250329214903273](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250329214903485.png)

- 全外连接

全外连接步骤如下 : 

1. 左外连接
2. 右外连接
3. 自然连接
4. 将左侧关系中所有与右侧关系中任一元组都不匹配的元组，并填充右侧关系中所有与左侧关系中任一元组都不匹配的元组，将产生新元组加入自然连接结果中（`大白话：将左侧连接中存在null的元组行加入到自然连接中，右侧连接同理`）

![image-20250329220000014](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250329220000254.png)

## SQL 语言分类

- DDL 数据定义语言 ：

```sql
# 建立数据库
create database 数据库名
# 建立基本表
create table 表名 (
列名 数据类型,
...
完整性约束,
PRIMARY KEY # 主键子句（实体完整性）
CHECK	    # 检查子句 （用户自定义完整性）
FOREIGN KEY # 外键子句（参照完整系）
...    
)
#
alter
#
drop
```

- DML 数据操纵语言 ：

```sql
insert(插入)
delete(删除)
update(更新)
```

- SQL 数据查询语言

```sql
select distinct 列名 from 表
# distinct 去除列中重复元素

select 列名 as '别名' from 表名
# as  标题名

where 分数 between 60 and 80
#  [60, 80] 两者之间

where 姓名 like '王%_'
# 模糊查询 %任意长度, _任意单个字符

select * from 表名 order by 列名 asc, 分数 dese
# order by 子句必须是select命令中的最后一个子句 升序(默认ASC)、降序(DESC)

```

聚合函数

```sql
select count(*) from 表名

select AVG(列名) from 表名

select min(列名) from 表名

select max(列名) from 表名

select sum(列名) from 表名

# 条件里面包含聚合函数是不能用where只能用having

例子：可看分组第一个
```

分组

```sql
# 除了聚合函数以外公共属性都需要放到分组里面
select 学号 
from 表名 
where 分数 is not null 
group by 学号
having min(分数) > 70 and max(分数) < 90

# 由group对选取进行分组，执行聚合函数，执行having子句选取满足条件的分组
```

内连接，外连接

```sql
from 表1 inner join 表2 on 条件 # 内连接

left outer join 表2 on 条件

left outer join 或 left join # 左外连接

right outer join 或 right join # 右外连接

full outer join 或 full join # 左外连接
```

子查询

```sql
# 默认一个子查询的返回值只为一个 使用 = 进行比较
# 一个子查询的返回值为多行时，需要使用 ANY、ALL、IN、NOT IN、等选项，他们与查询条件一起构造返回一组值的子查询
例： 分数 > （ ANY、ALL、IN、NOT IN ）子序列为，10，20，30

ANY : 只需要满足子序列其中任意一个就可以
ALL : 需要满足子序列所有条件
IN ：

where 教师编号 IN (select  x.)

```

相关子查询

```sql
# exists 如果存在这样的行，exists子句便返回为真，如果未查询到子句则返回为假
# no exists 相反
where exists (select )
```

并、交、差

```sql
union : 并
intersect : 交
except : 差

select * from 表1 union select * from 表2
```

- DCL 数据控制语言

```sql
# 数据库对象的权限 和 事务管理
DBA 数据管理员（给用户分配权限）

GRANT 授权， REVOKE 回收权限

where check option (插入修改保证视图唯一)

where grant option to public (授权给所有用户)

where grant option to user(授权给用 用户，用户可以授权给别人)
```

索引

```sql
unique # 表明此索引的每一个索引值只对应唯一的数据记录

create unique index 索引名
drop index 
```

## 函数依赖

R<U,F>

R : 关系名

U : 属性

F : 函数依赖

U公共属性

| 学号 | 姓名 | 课程号 | 课程名 | 成绩 |
| ---- | ---- | ------ | ------ | ---- |

F依赖函数 ：(X -> Y 解释) X 决定 Y, Y 依赖 X

| 学号->姓名 | 课程号->课程名 | (学号，课程号)->成绩 |
| ---------- | -------------- | -------------------- |

包含**⊇**、包含于**⊆**、不包含于**⊈**

{1，2，3} **⊇** {1，2}

{1，2} **⊆**{1，2，3}

{4} **⊈**{1，2，3}

非平凡的函数依赖：如果x->Y，但Y **⊈**X

平凡凡的函数依赖：如果x->Y，但Y **⊆**X

完全函数依赖：如果x->Y,并且对于X的任何一个真子集x'都有x'不能决定Y,则称Y对X完全函数依赖

部分函数依赖：

传递依赖：

## 范式

- 1NF : 成立就是1NF
- 2NF ： 不存在部分依赖（候选码`A`BD,C是部分依赖于`A`的） BCD->A、`A->C`
- 3NF : 传递依赖A->B、B->C
- BCNF : 左边的全是候选码

- 4NF :  多值依赖 x ->-> y


## 数据库设计步骤

1. 用户需求分析
2. 概念设计
3. 逻辑设计
4. 物理设计

## 数据库事务的四大特性

数据库事务( transaction)是访问并**可能操作各种数据项的一个数据库操作序列**，这些操作**要么全部执行,要么全部不执行，是一个不可分割的工作单位。**事务由事务开始与事务结束之间执行的全部数据库操作组成。

ACID

- **原子性**（Atomicity）事务中的全部操作在数据库中是不可分割的 **要么全部完成，要么全部不执行**
- **一致性**（Consistency）几个并行执行的事务，其执行结果**必须与按某一顺序串行执行的结果相一致**
- 隔离性（lsolation）:事务的执行**不受其他事务的干扰**，事务执行的**中间结果对其他事务必须是透明的**（指多个并发独立事务，相互独立、相互隔离、互不影响）
- 持久性（Durability）对于**任意已提交事务**，系统**必须保证该事务对数据库的改变不被丢失**，即使数据库出现故障

## 数据库触发器

select **不会触发触发器**

触发器是一种**自动化机制**，能够在**特定数据库操作**（如 insert, update, delete）发生时自动执行预定义的逻辑

- 触发器的作用
  - 数据完整性：验证或约束数据修改，确保符合业务规则
  - 级联操作：自动更新/删除关联表中的数据
  - 审计与日志：记录数据变更的详细信息（如果操作时间、用户、旧值/新值）
  - 业务逻辑封装：将复杂逻辑嵌入数据库层，减少应用层代码依赖
- 触发器的分类
  - 按事件触发：DML触发器（insert,update,delete）、DLL触发器（create,alter,drop）
  - 按执行粒度：行级触发器（每行数据变更触发，影响一行）、语句级触发器（整个SQL语句触发）
  - 按触发时机：BEFORE触发器（操作前触发），AFTER触发器（操作之后触发）





# 面向对象

一个对象通常由：对象名，属性，方法3个部分组成

多态:

- **包含多态**在许多语言中都存在，最常见的例子就是**子类型化**一个类型是另一个类型的子类型
- **过载多态**是同一个名字在不同的**上下文中所代表的含义不同**
- **参数多态** 是 **最纯的多态**

- 客户类无需知道所调用方法的特定子类的实现

## 面向对象设计的原则

1. 单一责任原则 : 就一个类来说应该仅有一个引起变化的原因
2. 开放封闭 : 对扩展开放，对就修改关闭
3. 里氏替换 : 子类 能替换 父类，父类出现的地方子类一定能出现
4. 依赖倒置原则 赖于底层模块，二者都应该依赖于抽象、抽象不应该依赖于细节、细节可以依赖于抽象 
5. 接口分离原则 : 依赖于抽象，不依赖于具体
6. 共同重用原则 : 重用了包中一个就应该重用所有
7. 共同封闭原则 : 一个变化若对一个包产生映像，则将对该包中的所有类产生影响，而对其他的包不造成任何影响
8. 无环依赖原则 : 在包的依赖关系图中不允许存在环，包之间的结构是一个直接的五环图
9. 稳定依赖原则 : 朝着稳定的方向进行依赖
10. 稳定抽象原则 : 包的抽象程度应该和其稳定程度一致

## 面向对象分析5个活动

1. 认定对象 2. 组织对象 3. 对象间的互相作用 4. 基于对象的操作

面向对象设计的活动:

## 面向对象设计时包含的主要个活动

1. 识别类及对象 2. 定义属性 3. 定位服务 4. 识别关系 5. 识别包

## 面向对象软件的测试可分为下列4个层次进行

1. 算法层 2. 类层 3. 模板层 4. 系统层

#  操作系统

## linux 文件目录

| 级别   | 目录  | 描述                                                         |
| ------ | ----- | ------------------------------------------------------------ |
| 根目录 | /     | Linux系统的根目录，所有目录都是由根目录衍生出来的，根目录与系统的开机、修复、还原密切相关 |
|        | /bin  | bin 二进制文件，目录存放着最经常使用的命令                   |
|        | /boot | 系统引导文件存放目录，存放着启动linux时使用的一些核心文件，包括一些连接文件以及镜像文件 |
|        | /dev  | dev（Device 设备）目录存放的是linux的外部设备及特殊文件存储位置 |
|        | /etc  | etc(Etcetera: 等等) 目录存放所有的系统管理所有需要的配置文件和子目录 |
|        | /hmoe | 用户的主目录，在Linux中，每个用户都有一个自己目录，一般目录名是以用户的账号命名 |
|        | /root | 该目录为系统管理员（超级权限者用户主目录）                   |
|        | /run  | 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删除或清除 |
|        | /sbin | s(super User)是超级用户的二进制文件的缩写，存放的是系统管理员是使用的系统管理程序 |
|        | /tmp  | 目录是用来存放一些临时文件                                   |
|        | /usr  | usr （unix shared resources 共享资源） 目录下存放用户的很多应用程序和文件，类似于windows下的program files目录 |
|        |       |                                                              |
|        |       |                                                              |
|        |       |                                                              |
|        |       |                                                              |
|        |       |                                                              |

![image-20250724221128024](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250724221135328.png)

## 前趋图

p -= 1 申请

v += 1

![image-20250507203409422](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250507203416719.png)

## 进程的三态模型

![image-20250509213225487](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250509213232734.png)

| 进程 | CPU  | 资源 |
| ---- | ---- | ---- |
| 运行 | √    | √    |
| 就绪 | ×    | √    |
| 阻塞 | ×    | ×    |

## 死锁

1. 同类资源分配不当引起死锁

m个资源、n个进程、每个进程需要k个

m < n * k 可能引发死锁
$$
m >= n * (k - 1) + 1 不会发生死锁
$$

## 进程资源图

1. 先申请资源
2. 在分配资源

## 死锁避免

死锁策略主要有四种：**鸵鸟策略**、预防策略、**避免策略**、检测与解除死锁 

死锁避免 ： Dijkstra提出的银行家算法

## 线程

进程 ：可用资源的独立单位

线程 : 可独立调度和分配的基本单位
进程P创建若干线程可以共享 ： 该进程的代码段、该进程中打开的文件、该进程的全局变量、

## 分页存储管理

![image-20250513214320860](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250513214328154.png)

## 段页式存储管理

 ![image-20250513215953784](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250513215954036.png)

## 单缓冲区

非满不能传送，非空不能输入

`建议考试推一下`

![image-20250513221326812](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250513221327062.png)

双缓冲区 ： T * n + m + c （需要满足 m + c < T）

## 磁盘调度算法

先进行移臂调度，在进行旋转调度

磁盘转速提高一倍，旋转等待时间减半

随时改变移动臂 ： 先来先服务 和 最短寻找时间优先

SCAN(扫描\电梯调度算法) 要么往左 要么往右 9 8 7 5 6

CSCAN(单向扫描) 6 5 8 9

![image-20251016212535599](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20251016212543195.png)



## 旋转调度算法

![image-20250515220159939](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250515220207302.png)

优化后~

![image-20250515220631517](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250515220631775.png)

![image-20250515221540553](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250515221540783.png)

## 多级索引结果

unix系统

![image-20251018124847360](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/202510181248758.png)

![image-20251016231814499](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/202510172115531.png)

![image-20251016231752740](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/202510172116463.png)

![image-20251017213348229](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/202510172133685.png)

## 文件目录

文件控制块主要包含三类信息：基本信息、存取控制信息类和使用信息类

基本信息：**文件名**、**文件物理位置**、**文件长度**、**文件块**等~

像UNIX用户分成文件组、同组用户和一般用户三类，这三类用户的读/写执行 RWX权限

若系统正在 `目录`文件修改的结果写回磁盘时发生系统崩毁，则对系统的影响比较大

`全文件名`: D:\Program\C-prog\f1.c

`绝对路径` ：D:\Program\C-prog\

`相对路径 (当前处于 Program)`:Program\C-prog\

或**.**\Program\C-prog\

或 C-prog\

考试题目相对可能没有Program\

![image-20250516205222332](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250516205229619.png)

## 位示图

用二进制的一位来表示一个物理块的使用情况

![image-20251018084635686](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/202510180846154.png)

## 设计原则

**作用范围**应该在其**控制范围之内**

采用过程抽象和数据抽象设计

## 杂题

windows操作系统 双击xxxx.jpg文件时系统回自动通过建立`文件关联`来决定使用什么程序打开该图像

实时系统对来自外部的事件必须在`被控对象的时间内做出及时响应并对其进行处理`

IO软件隐藏了IO操作实现的细节，方便用户使用IO设备



# UML

4种关系，依赖、关联、泛化、实现

1. 依赖

![image-20250519192930392](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250519192937679.png)

2. 关联

角色 ： 雇主、员工

多重度 : 就是上面 0...1 、 0...*

![image-20250519193906121](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250519193906369.png)

**聚合** ：部分和整体的的生命周期**不同**，**整体消失，部分仍然存在**，部分可以脱离整体存在

例 : 公司消失了，员工不会消失（换个工作）

 ![image-20250519194354730](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250519194354960.png)

**组合** ：部分和整体的的生命周期**相同**，**整体消失了，部分也会消失**，部分不可以脱离整体存在

![image-20250519194732734](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250519194732974.png)

3. 泛化 ： **父类**泛化**子类**

![image-20250519195609630](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250519195609857.png)

4. 实现

![image-20250519195822024](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250519195822254.png)

![image-20250519200754355](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250519200754605.png)

`+`:public 公有的

`-`:private 私有的

`#`:proteated 受保护的

`~`:package 包的

## 用例图

1. 包含

用例与用例之间的关系 A 包含 B

![image-20250519204600999](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250519204601246.png) 

2. 扩展

一个用例执行的时候可能会发生一些特殊的的情况

B 扩展 A、 (可选的情况)A--->B

吃法  <--- 打印发票

![image-20250519210422277](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250519210422540.png)

3. 泛化

两种选一种

**参与者与参与者**、**用例与用例**的关系

![s](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250519211108022.png)

# 结构化

## 耦合

无直接耦合 ： 两个模块之间没有直接的关系，他们分别从属于不同的模块

数据耦合 ： 两个模块之间有**调用**关系是简单的**数据值**

标记耦合 ： 两个模块之间传递的是**数据结构**

控制耦合 ： 一个模块**调用**另一个模块时传递的是**控制变量**

外部耦合 ：通过软件之外的环境联结（**IO**将模块耦合到特定的设备、格式、通信协议上）

公共耦合 ：通过一个公**共数据环境** 相互作用

内容耦合 ：一个模块直接使用另一个模块的**内部数据**，一个模块通过非正常入口转入另一个模块

## 内聚

内聚性 高 -> 低

模块独立性 强(功能单一) -> 弱(功能分散)

一个块内部元素（数据、处理）之间联系的紧密程度。块内联系愈紧，即内聚性愈高，模块独立性愈好

- 功能内聚：完成**单一**功能，各部分协同工作缺一不可
- 顺序内聚：处理元素相关，且顺序执行（上一个输出是下一个的输入）
- 通信内聚：所有元素集中在一个**数据结构的区域上**
- 过程内聚：必须按特定的次序执行
- 瞬时内聚/时间内聚：任务必须**同一时间**间隔执行
- 逻辑内聚：完成逻辑上相关的一组任务、模块内若干个逻辑上相似的功能
- 偶然内聚/巧合内聚 ： 一个模块内的个处理元素之间没有任何联系

## 设计原则

划分模块的原则 ： 作用范围应该在其控制范围之内  

模块设计 不能改进设计质量 ：模块的功能越单纯越好

## 数据字典

数据流图中的元素 在 数据字典 中进行定义

数据字典条目 ：数据流、数据项、数据存储、加工\\基本加工

对每一个基本加工，必须有一个加工规格说明

加工规格说明必须描述把输入数据流变换为输出数据流的加工规则

决策表/判定表 可以用来表示加工规格说明

结构化语言，判定树和判定表可以用来表示加工逻辑



# 软件工程

软件工程基本要素包括 ：方法、工具、过程

- 集成测试：聚焦模块间接口（如调用顺序，数据格式），直接暴露接口问题
- 单元测试：仅测试单个模块内部逻辑，不涉及模块交互
- 系统测试：验证整体功能，接口问题可能已被集成阶段排除
- 验证系统：验收用户需求，不检查技术性接口细节

## 软件配置管理

配置数据库：

1. 开发库
2. 受控库
3. 产品库

软考配置管理`活动/目标`

1. 变更标识
2. 变更控制
3. 版本控制
4. 变更报告
5. 确保变更正确的实现

软考配置管理`内容`：

1. 版本管理
2. 配置支持
3. 变更支持
4. 过程支持
5. 团队支持
6. 变化报告
7. 审计支持

or

1. 软件配置标识
2. 变更管理
3. 版本控制
4. 系统建立
5. 配置审核
6. 配置状态报告

## 风险

软件风险 ： 不确定性和损失

风险预测 两个方面评估 ： **风险发生的可能性**以及**风险发生所产生的后果**

风险评估 ： 一种对风险评估很由用的技术就是定义风险参照水准

风险控制（下面3点） ： 目的是辅助项目组，建立处理风险的策略

1. 风险避免 ： 应对风险的最好办法是`主动地避免风险`
2. 风险监控 ： 对风险实时监控，
3. 风险消除 ： 只能消除一小部分的风险
4. 风险监测 ：评估所预测的风险是否发生，保证正确实施了解风险缓解步骤，收集用于后续进行风险分析的信息

项目风险 ： 项目复杂性、规模和结构的不确定性属,预算、进度、人员

技术风险 ：要开发软件的质量及交付时间，前沿技术

商业风险 ：威胁到要开发软件的生存能力

风险的优先级通常是根基 ： `风险暴露` 设定

## 软件质量

![image-20250925222225962](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250925222233364.png)

Mc Call软件质量模型

![image-20250927101720409](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250927101727997.png)

## 设计质量的评审内容

 ![image-20250927102201034](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250927102201805.png)

## 软件能力成熟度模型 CMM

五级

1. 初级  : 软件过程特点杂乱无章，有时甚至很混乱，几乎没有有明确定义的步骤，全依赖个人努力，和英雄式核心人物的作用 
2. 可重复级 ： 建立了基本的`项目`管理和实践跟踪项目费用、进度和功能特性
3. 已定义级 ： 使用`标准`软件过程
4. 已管理级 ： `管理层 `，制定软件过程和`产品质量`的详细度量标准。软件过程的产品质量都被开发组织成员所`理解和控制`
5. 优化： ： 通过来自过程反馈和来自新观念

## 软件能力成熟度模型 CMM`I`

CMMI 提供了两种表示方法：`阶段是模型` 和 `连续式模型`

1. 初始的：过程不可预测且缺乏控制
2. 已管理的：过程为`项目`服务
3. 已定义的：过程为`组织`服务
4. 定量管理：过程已`度量`和`控制`
5. 优化的：集中于过程改进

CMMI 中包括6个过程域能力等级，等级号0-5

CL0

CL1 已执行:过程将可标识的`输入`工作产品`转换`成可标识的`输出`工作产品，以实现支持过程域的特定目标

CL2

CL3 已定义级 ：关注过程的组织和标准化和部署

CL35 优化的:以对客户要求的改进和持续改进技术中的过程域的功效 

## 瀑布模型

软件生存周期中的各个活动规定，为`顺序连接`,的若干阶段的模型包括 ： 需求分析、设计、编码、测试、运行、维护，由前至后、相互衔接的固定次序

以`项目的阶段评审`和`文档控制`为手段

**容易理解，管理成本低**；强调开发的阶段性早期计划及需求调查和产品测试

不足之处是，客户必须能够完整、正确和清晰地表达他们的需求

例子 ：具备了相关领域及类似规模系统的`开发经济`

例子 ：新开发一个系统，以替换原有的系统

---

V模型: `质量保证活`动和`沟通`、`建模`相关活动以及早期构建相关的活动之间的关系

![image-20250928201412924](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250928201420458.png)

## 增量模型

增量模型 = 原型实现迭代特征 + 瀑布模型的基本成分

分析 -> 设计 -> 编码 -> 测试

第一个增量往往是核心的产品。客户对每一个增量的使用评估作为下一个增量发布的新特征和功能

**具有瀑布模型优点** 容易理解，管理成本低；强调开发的阶段性早期计划及需求调查和产品测试，**第一个可交付版本所需要的成本和时间很少**

开发由增量表示的小系统所承担的风险不大，由于很快发布第一个版本，因此可以减少用户需求的变更，**运行增量投资，即在项目开始时可以仅对一个或两个增量投资**

**是一种适用于商业产品的创新模型**

缺点 ： 管理发生的**成本**、**进度**配置的复杂性可能**会超出组织的能力**

`不是增量` ： **很容易**将客户需求划分为多个增量

`不是增量` ：有利于进行更好的模块划分

√ ： 它假设可以将需求分段为一系列增量产品，每一个增量可以分别开发 

![image-20250928205500857](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250928205501374.png)

## 原型模型-演化模型

`演化模型 - 不断演变的软件产品过程模型、对软件需求缺乏认识的情况`

`帮助用户确定需求`

适用于用户需求不清，需求经常变化的情况。当系统规模不是很大不是很复杂的时，采用该方法比较好

快速低成本，构建原型

对于计算机不是很熟悉的用户可以根据这个框架提出自己的需求

例 ：有效地捕获系统需求，采用原型模式

![image-20250928221724771](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250928221725170.png)

## 螺旋模型-演化模型

`演化模型 - 不断演变的软件产品过程模型、对软件需求缺乏认识的情况`

最适合于大规模团队开发的项目、`风险分析`、庞大、复杂并且具有高风险的系统

需要开发人员具相当丰富的风险评估经验和专门知识，支持用户需求的动态变化

1. 制定计划 ：确定软件的目标，选定实施方案，明确项目开发的限制条件
2. 风险分析 ：分析所选的方案，识别风险，消除风险
3. 实施工程 ： 实施软件开发，验证阶段性产品
4. 用户评估 ： 评价开发工作，提出修正建议，建立下一个周期的开发计划

![image-20250929212738587](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250929212746167.png)

## 喷泉模型

`以用户需求为动力`，以`对象作为驱动`的模型，适用于面向对象的开发方法。它`克服了`瀑布模式`不支持软件重用`和多项开发活动集成局限性

使开发过程具有`迭代性`和`无间隙性`，开发人员可以同步进行

![image-20250929220954210](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250929220954688.png)

## 白盒测试

6种  语句覆盖 < 判定覆盖 < 条件覆盖 < 判定条件覆盖 < 条件组和覆盖 < 路径覆盖

### 语句覆盖

每条语句都要执行一次

下图 ： 1，7，5，6，8 是语句

Ps: 个人总结 除逻辑判断外均为语句需要执行

![image-20250521222909812](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250521222910097.png)

### 分支覆盖（判定覆盖）

条件的真假都需要取到

Ps：每条yes 和 false 都需要执行  

![image-20250521222425484](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250521222432847.png)



### 条件覆盖

每一判定语句中每个逻辑条件的各种可能的值至少满足一次

![image-20251007115519878](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20251007115527344.png)

### 判定条件覆盖

判定 + 条件

![image-20251007115917040](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20251007115917446.png)

### 条件组合覆盖

![image-20251007120247629](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20251007120248067.png)

### 路径覆盖

对于程序流图中每一条可能的路径都覆盖掉 **下图为四条路径**

![image-20251007120631801](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20251007120632192.png)

## 黑盒测试

黑盒测试也是功能测试，只关心软件的**输入**数据和**输出**数据

例 x = 2(输入) -> 【黑盒】 ->  x = 4(输出) ： 不关心过程只需要知道结果是4

### 等价类划分

吧程序的**输入域**划分若干部分，然后从每个部分中**选取少数代表性数据**当作测试永烈

例1 : 密码正确，密码错误、邮箱正确、邮箱错误

有效 和 无效 数据

### 边界值分析

边界值分析法**输入或输出**的**边界值**进行测试

例 ：输入为1986年6月9号，则该函数的输出应为1986年6月10号（输入的最后一天）

![image-20250823181534619](C:\Users\16583\AppData\Roaming\Typora\typora-user-images\image-20250823181534619.png)



## McCabe度量

1. 边数 - 节点数 + 2
2. 闭合区 + 1

## 系统可维护性的评价指标

1. 可理解性，2.可测试性、3.可修改性 

## 软件维护

软件维护要比软件开发的时间要长，其投入也大的多

`文档` 是软件可维护性的 `决定因素`

软件系统 文档可以分为 用户文档 和 系统文档两类

必须在**开发阶段**，保证软件具有可维护的特点，**每一个阶段**都应该考虑提高软件的可维护性 

## 软件文档

选项中说软件**文档不好的就是不正确**

## 软件维护

1. 正确性维护 ： 正在系统开发阶段发生而系统测试阶段尚未发现的错误，在运行时发现错误，并修改 （例：进行防错性程序设计，可以有效地控制 **正确性** 维护成本）
2. 适应性维护 ： **适应信息技术变化**和**软件管理需求变化**而进行的修改
3. 完善性维护 ： **扩充功能**和**改善性能**而进行修改
4. 预防性维护 ： 为了改进应用软件的可靠性和可维护性，应主动增加预防性的新的功能

## 可靠性、可用性、可维护性 （背）

- 可靠性 ：MTTF ( 1 + MTTF) : 一个系统在给定时间间隔内和给定条件下无失效运行的概率 
- 可用性 ：MTBF ( 1 + MTBF ) ： 在给定的时间点上，一个系统能够按照规格说明正确运作的概率
- 可维护 ：1 / （ 1 + MTTR ) ： 在给定条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率

## 沟通路径

n个人

1个人 路径 n - 1

2个人 路径 n - 2

3个人 路径 n - 3

等差数列 ( (n - 1) * n ) / 2

主程序员 普通程序员

主程序员 路径 n - 1

![image-20251007195103325](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20251007195103713.png)

## 软件项目估算

基本COCOMO 模型 ：静态单变量模型

中级COCOMO 模型 ：静态多变量模型

详细COCOMO 模型 ： 系统、子系统、模块 3个层次

COCOMO II ： 三个阶段模型 1、对象点 2、功能点 3、代码行

## 项目活动图



# 设计模式

![image-20251018204027343](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/202510182040699.png)

1 创建型 `类`/`对象` ：**单抽元件厂**
单：单例模式（Singleton）：唯一实例、**保证一个类仅有一个实例，并提供一个访问它的全局访问点**
抽：抽象工厂模式（Abstract Factory）：抽象接口，提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定具体的类、**提供一个创建一系列相关或互相依赖对象的接口，而无须指定他们具体的类**
元：原型模式（Prototype）：原型实例拷贝、**用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象**
件：构建者模式/生成器（Builder）：类与构造分离，链式赋值，同样的过程可生成不同的对象
厂：工厂方法模式`类`（Factory Method）：子类决定实例化



2 结构型：**外侨组员带配饰**
外：外观模式（Facade）：对外统一接口、**为子系统中一组接口提供一个一致的界面**
侨：桥接模式（Briage）：**抽象和实现分离**，抽象类中的功能抽象、**使它们可以独立地变化**
组：组合模式（Composite）：整体-部分，树形结构、**将对象组合成树型结构以表述“部分-整体”的层次结构**
员：享元模式（Flyweight）：细粒度，共享、**运用共享技术有效地支持大量细粒度的对象**
带：代理模式（Proxy）：代理控制、**为其他对象提供一种代理/包装以控制这个对象的访问**
配：适配器模式`类、对象`（Adapter）：转换，兼容接口、**将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作**
饰：装饰模式（Decorator）：附加职责、**动态地给一个对象添加一些额外的职责/行为**

3 行为型：**观摩对策，责令解放，戒忘台**
观：观察者模式（Observer）：通知，自动更新
摩：模板方法`类`（Template Method）：定义固定步骤，具体实现可变化
对：迭代器模式（Iterator）：顺序访问，不暴露内部、**提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示 **
策：策略模式（Strategy）：算法替换
责：责任链模式（Chain of Responsibility）：传递请求，职责链接、**使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系**
令：命令模式（Command）：日志记录，可撤销、**将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化**
解：解释器模式`类`（Interpreter）：解释器，虚拟机、**给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子**
放：访问者模式（Visitor）：数据和操作分离
戒：中介者模式（Mediator）：不直接引用、**用一个中介对象来封装一系列的对象交互。中介者使对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间交互**
忘：备忘录模式（memento）：保存，恢复
台：状态模式（State）：状态

# 数据结构

`稀疏矩阵`压缩存储方式 ：`三元组顺序` 和 `十字链表`

## 树

`树中结点总数`等于树中`所有结点`的`度`数之和`加1`

![image-20250915204711486](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250915204718867.png)

完全二叉树 : 顺序存储结构

一般二叉树 ： 链式存储

采用`三叉链表`存储二叉树，则链表的所有结点中空指针的数目为n个结点，`n+2`空指针 

二叉链表中空指针 `n + 1`

平衡二叉树：`任意一个结点`左右子树高度之差的绝对值不超过1 `<=1`

二叉排序树：所有根结点大于左子树所有结点，小于右子树所有结点，中序遍历是有序序列

哈夫曼编码 ：

用n权值构建一棵最优二叉树，二叉树结点总个数是`2n - 1`

字符个数 n = 6

| 字符    | a    | b    | c    | d    | e    | f    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 频率(%) | 18   | 32   | 4    | 8    | 12   | 26   |

**定长编码** ： 2^x^ >= n, 2^3^ >= 6, 也就是`3`个二进制可以表示一个字符

**定长编码**使用**频率** = 3 * 18 + 32 * 3 + 4* 3 + 8* 3 + 12 * 3 + 26 * 3 = 300

![image-20250917202636315](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250917202643747.png)



## 图

强连通图 ： 任意两个顶点存在一条路径

`无向图`深度/广度时间复杂度：邻接矩阵（n^2^）,邻接表（n + e）

拓扑序：

可能存在弧<vi， vj>， 一定不存在弧<vj, vi>

可能存在vi到vj的路径，一定不存在vj到vi的路径

# 计算机网络

计算机网络中，单播，组播，广播三种数据传输方式

1. 单播：一对一的传输方式，其中数据从**单一源发送到唯一的目的地**
2. 广播：一对多的传输方式，**数据被发送至局域网内的所有主机**
3. 组播：是中介于单播和广播之间的传输方式。它允许数据一对一组的基础上传输



物理层（不能隔离广播和冲突）：中继器，集线器

数据链路层（可以隔离冲突域，不能隔离广播）： 交换机、网桥

网络层：路由器，IP，icmp, ARP, RARP

传输层：TCP, UDP(Voip 视频通话)

`交换机`是一种多端口`网桥`  

集线器是一种多端口中继器（不对信号做任何处理，但是可以检测冲突）

![image-20250920141451168](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250920141458520.png)

![image-20250920141801378](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250920141801702.png)

## 协议簇

![image-20250920144327534](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250920144327826.png)

FTP控制端口 21， 上传文件时的端口为 20

ARP（广播）:地址解析，`IP `转换成`MAC`地址

RARp（单播）:反地址解析 `MAC` 转换成 `IP`

SMTP 发送邮件 仅支持ACSCII，文本，POP3接收邮件

TCP/IP 建立连接进行可靠通信在OSI/RM ： 会话层

DHCP ： 获得本机ip地址，DNS服务器地址，DHCP服务器地址，默认网关的地址， `分配失败`情况下默认地址（`169.254`.0.0/16）

![image-20250920211020566](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250920211020873.png)

## 浏览器

在浏览器输入一个正确网址后本地主机将：

本地的host文件->本地DNS缓存->本地DNS服务器->根域名服务器

主域名服务器在收到域名请求后，查询顺序：

本地缓存->本地host文件->本地数据库->转发域名服务器 

## ip地址与子网掩码

![image-20250921100028574](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250921100035970.png)

例 划分多少个子网：

如一个B类的子网掩码为255.255.224.0则这个网络被划分成了__个子网

B类:

16位 网络地址 255.255.0.0

16位 主机地址 255.255.`224`.0

224 = 1110 0000 0000 0000

也就是借三个主机为子网号，也就有2^子网号^ = 2^3^ = 8个子网

例 ip地址块 222.125.80.128/26包含了\___可用地址，最小地址\___最大地址\__

网络地址有26个，32 - 26 = 6个主机地址

全0 ：网络地址，全1 ：广播地址

2^6^ - 2(全0/1) = 62个主机地址

128 = `10`00 0000 前两个为网络地址

最小地址 = `10`00 0001 = 222.125.80.`129`

最大地址 = `10`11 1110 = 222.125.80.`190`

超网

4地址需要几个主机位表示 2^x^ >= 4;, 从网络位里面减去

![image-20250921102306692](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250921102307014.png)

ipv6 地址空间128个 ipv4 地址空间是32个

## Windows命令

ping命令由进到远，顺序ping127.0.0.1 其次 ping本地ip,再次是ping默认网关，最后ping远程主机

```cmd
ipconfig #显示所有网络适配器IP地址、子网掩码和网关

ipconfig/release # DHCP客户端手工释放IP
ipconfig/renew # DCHP客户端手工向服务器请求刷新（重新获取ip）
/reload # 重新加载
/reset # 重新设置

ipconfig/flushdns # 清除本地DNS缓存内容（刷新DNS解析缓存）
ipconfig/displaydns #显示本地DNS内容
ipconfig/registerdns #dns客户端手工向服务器注册
ipconfig/adll # 显示所有网络适配器的完整TCP/IP，包括DHCP服务是否启动
```

DNS故障检测

![image-20250921162034557](https://typora-images-qz.oss-cn-beijing.aliyuncs.com/img/20250921162034969.png)

## 路由

Windows 收到一个数据包时，先查找`主机路由`，在查找`网络路由(直连网络和远程网络)`这些查找时败时候，查找`默认路由`

路由收到多个，比较各个路由的管理距离

| 路由类型 | 说明                          |
| -------- | ----------------------------- |
| 主机路由 | 默认子网掩码为255.255.255.255 |
|          |                               |
| 默认路由 | 默认子网掩码为0.0.0.0         |

静态路由 ： 不更新，除非拓扑结构变化

洪泛式 ：不依据网络信息

随机路由 ： 是洪泛式的简化

自适应路由 ： 依据网络信息进行最小代价计算

## 杂项

1. 工作区子系统 ： 由终端设备到信息插座的整个区域
2. 水平子系统 ： 楼层接线间的配线架到工作区信息插座之间所安装的线缆
3. 管理子系统 ： 
4. 干线子系统 ： 各层设备之间互连系统
5. 设备间子系统
6. 建筑群（园区子系统）子系统 ： 连接各个建筑物的通信系统

ASP的内置对象中，只有`Response`对象可以修改Cookie中的值

`DNS`中，`启用循环添加每个web服务器主机记录`就可以确保域名解析并实现`负载均衡` 

要使两个IPv6通过现有的ipv4网络通信，则应该使用`隧道技术`

`纯IPv6`结点可以与`纯IPv4`结点进行通信则需要使用`翻译技术`

域名无法网站，但是IP可以访问网站，可能原因

1. 该计算机设置的本地DNS服务器工作不正常
2. 该计算机的DNS服务设置错误
3. 本地DNS服务器网络连接中断

5G 2016至今 无立标准，但主导SEP 

异步通信 1位起始，7个数据位，2终止，每秒500字节有效传输速率`500 * 7 = 3500b/s`

ADSL 拨号安装pppoe

`协议名：//主机名.域名。域名后缀。域名分类/目录/网页文件`

 

# 信息安全

## 防火墙

包过滤防火墙对数据包的过滤包括 ： 源IP地址，源端口号地址，目的IP地址，协议等

包过滤防火墙处在 网络层 和数 据链路层 ，对网络层数据报进行检查,安全性低，直接转发报文，对用户完全透明，速度更快， 

受保护程序 ： 内网 `>` DMZ `>` 外网。内网->(访问) DMZ <-(访问)外网， 内网 也可以直接访问 外网

应用代理防火墙 ： 彻底隔离内网与外网的直接通信

## 病毒

病毒 ： 传播、隐蔽、感染、潜伏、触发、破坏等

worm蠕虫、Trojan特洛伊木马（内部 与 外部主机建立连接）、Backdor后门病毒、macro宏

宏 ：文本文档、电子表格

## 网络攻击

ARP攻击欺骗：伪造IP地址和MAC地址，能够在网络中产生大量的ARP通信量使网络阻塞，造成无法跨网段通信、`伪造网关ARP报文使得数据包无法发送到网关`

SYN Flooding攻击是 DoS 

数据库容灾 属于： `系统安全`和`应用安全`

防范网络监听： 数据加密

IE浏览器中，安全级别最高的是 受限站点

 IIS6.0 身份验证4种机制 ： 集成windows身份验证 > 摘要身份验证 > .NET Passport 身份验证 > 基本身份验证

TLS最接近的协议 ： SSL是TLS的升级版

AGP 电子邮件信息 加密

HTTPS : http + ssl 加密

IPSec : 对ip数据报文的加密

WEP ： 有限等效保密协议

信息安全存储安全:

1. 机密性 ： 确保信息不是暴露给未授权的实体或进程
2. 完整性 ：只有得到允许的人才能修改数据，并且能够判别出数据是否已经被篡改
3. 可用性 ：得到授权的实体在需要时可以访问数据，即攻击者不能占用所有的资源而阻碍授权者的工作
4. 可控性 ：可以控制授权范围内的信息刘向及行为
5. 可审查性 ：对出现的信息安全问题提供调查的依据和手段 

